<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>ELEC-E5620 Audio Signal Processing 2023, Demo project: Moog Ladder Filter</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-03-01">
<meta name="DC.source" content="nonlinear.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>ELEC-E5620 Audio Signal Processing 2023, Demo project: Moog Ladder Filter</h1>
<!--introduction-->
<p>Pi, Wang, Benc</p>
<p>Implements and demonstrates nonlinearity by saturating different members of the difference equation of the second-order biquad filter.</p>
<p>References: [1] Configure the Coefficients for Digital Biquad Filters in TLV320AIC3xxx Family [online], 2010. Available: <a href="http://www">http://www</a>. ti. com/lit/an/slaa447/slaa447. pdf. [2] Chowdhury, "STABLE STRUCTURES FOR NONLINEAR BIQUAD FILTERS,&rdquo; Proceedings of the 23rd International Conference on Digital Audio Effects (DAFx-20), Vienna, Austria, September 8&ndash;12, 202.</p>
<p>Parameters: fc - Cut-off frequency (Hz). Q - Quality value (dB). fs - Sampling frequency (Hz). topology - Filter topology. Options: '0', ..., '9' - According to the chart attatched to the code. nonlinearity - Nonlinearity type. Options: 'soft' - Soft saturator. 'hard' - Hard saturator. 'tanh' - Tanh saturator. fs - Sampling frequency (Hz). inputSignal - Wave signal.</p>
<p>Output: normalizedOutputSignal - Nomalized filtered signal.</p>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#2">Parameters</a>
</li>
<li>
<a href="#3">Input signal</a>
</li>
<li>
<a href="#4">Calculation of the biquad filter coefficients [1]</a>
</li>
<li>
<a href="#5">Stability test</a>
</li>
<li>
<a href="#6">Nonlinearity function</a>
</li>
<li>
<a href="#7">Filtering</a>
</li>
<li>
<a href="#8">Normalization</a>
</li>
<li>
<a href="#9">Results</a>
</li>
</ul>
</div>
<pre class="codeinput">clear; clc; close <span class="string">all</span>;
</pre>
<h2 id="2">Parameters</h2>
<pre class="codeinput">fc=1000;
Q=10;
topology = <span class="string">'1'</span>;
nonlinearity = <span class="string">'hard'</span>;
</pre>
<h2 id="3">Input signal</h2>
<pre class="codeinput">
<span class="comment">% % Generate a logarithmic chirp signal</span>
<span class="comment">% fs = 48e3;</span>
<span class="comment">% t = 0:1/fs:10;</span>
<span class="comment">% f0 = 20;</span>
<span class="comment">% f1 = 20000;</span>
<span class="comment">% y = chirp(t, f0, max(t), f1, 'logarithmic');</span>
<span class="comment">% audiowrite('samples/sweep.wav', y, fs);</span>

filename = <span class="string">'samples/sweep.wav'</span>;
[inputSignal, fs] = audioread(filename);
</pre>
<h2 id="4">Calculation of the biquad filter coefficients [1]</h2>
<pre class="codeinput">w=2*pi*fc/fs;
alpha=sin(w)/(2*Q);
b0=(1-cos(w))/2;
b1=(1-cos(w));
b2=(1-cos(w))/2;
a1=-2*cos(w);
a2=1-alpha;
</pre>
<h2 id="5">Stability test</h2>
<p>Assuming that the corresponding linear filter is stable, the nonlinear feedback filter will be stable provided the absolute value of the derivative of fnn is always less than or equal to 1. [2]</p>
<pre class="codeinput">b = [b0, b1, b2];
a = [1, a1, a2];
flag = isstable(b, a);

figure;
zplane(b, a);
title(<span class="string">'Pole-zero plot'</span>);

<span class="keyword">if</span> flag==1
    disp(<span class="string">'Corresponding linear filter is stable.'</span>);
<span class="keyword">else</span>
    disp(<span class="string">'Corresponding linear filter is unstable.'</span>);
<span class="keyword">end</span>
</pre>
<pre class="codeoutput">Corresponding linear filter is stable.
</pre>
<img vspace="5" hspace="5" src="nonlinear_01.png" alt=""> <h2 id="6">Nonlinearity function</h2>
<p>Defining nonlinearity function used for saturation.</p>
<pre class="codeinput">
<span class="keyword">if</span> nonlinearity==<span class="string">'soft'</span>
    fnl = @(x) 3.*(1 ./ (1 + exp(-x))-0.5);
<span class="keyword">elseif</span> nonlinearity==<span class="string">'hard'</span>
    fnl = @(x) (x &lt; -1) .* -1 + (x &gt;= -1 &amp; x &lt;= 1) .* x + (x &gt; 1) .* 1;
<span class="keyword">elseif</span> nonlinearity==<span class="string">'tanh'</span>
    fnl = @(x) tanh(x);
<span class="keyword">else</span>
    error(<span class="string">'Invalid nonlinearity type.'</span>)
<span class="keyword">end</span>
</pre>
<h2 id="7">Filtering</h2>
<p>Applying the filtering based on the topology.</p>
<pre class="codeinput">outputSignal = zeros(size(inputSignal));

<span class="keyword">for</span> i=1:size(inputSignal, 2)
    <span class="keyword">for</span> n = 3:length(inputSignal)
        <span class="keyword">switch</span> topology
            <span class="keyword">case</span> <span class="string">'0'</span>
                outputSignal(n, i) = <span class="keyword">...</span>
                    b0 * inputSignal(n, i) + <span class="keyword">...</span>
                    b1 * inputSignal(n - 1, i) - <span class="keyword">...</span>
                    a1 * outputSignal(n - 1, i) + <span class="keyword">...</span>
                    b2 * inputSignal(n - 2, i) - <span class="keyword">...</span>
                    a2 * outputSignal(n - 2, i);
            <span class="keyword">case</span> <span class="string">'1'</span>
                outputSignal(n, i) = <span class="keyword">...</span>
                    b0 * inputSignal(n, i) + <span class="keyword">...</span>
                    b1 * inputSignal(n - 1, i) - <span class="keyword">...</span>
                    a1 * outputSignal(n - 1, i) + <span class="keyword">...</span>
                    b2 * inputSignal(n - 2, i) - <span class="keyword">...</span>
                    a2 * outputSignal(n - 2, i);
            <span class="keyword">case</span> <span class="string">'2'</span>
                outputSignal(n, i) = <span class="keyword">...</span>
                    b0 * inputSignal(n, i) + <span class="keyword">...</span>
                    b1 * inputSignal(n - 1, i) - <span class="keyword">...</span>
                    a1 * outputSignal(n - 1, i) + <span class="keyword">...</span>
                    fnl(b2 * inputSignal(n - 2, i) - <span class="keyword">...</span>
                    a2 * outputSignal(n - 2, i));
            <span class="keyword">case</span> <span class="string">'3'</span>
                outputSignal(n, i) = <span class="keyword">...</span>
                    b0 * inputSignal(n, i) + <span class="keyword">...</span>
                    fnl(b1 * inputSignal(n - 1, i) - <span class="keyword">...</span>
                    a1 * outputSignal(n - 1, i)) + <span class="keyword">...</span>
                    fnl(b2 * inputSignal(n - 2, i) - <span class="keyword">...</span>
                    a2 * outputSignal(n - 2, i));
            <span class="keyword">case</span> <span class="string">'4'</span>
                outputSignal(n, i) = <span class="keyword">...</span>
                    fnl(b0 * inputSignal(n, i) + <span class="keyword">...</span>
                    b1 * inputSignal(n - 1, i)) - <span class="keyword">...</span>
                    a1 * outputSignal(n - 1, i) + <span class="keyword">...</span>
                    fnl(b2 * inputSignal(n - 2, i)) - <span class="keyword">...</span>
                    a2 * outputSignal(n - 2, i);
            <span class="keyword">case</span> <span class="string">'5'</span>
                outputSignal(n, i) = <span class="keyword">...</span>
                    b0 * inputSignal(n, i) + <span class="keyword">...</span>
                    b1 * inputSignal(n - 1, i) - <span class="keyword">...</span>
                    fnl(a1 * outputSignal(n - 1, i)) + <span class="keyword">...</span>
                    b2 * inputSignal(n - 2, i) - <span class="keyword">...</span>
                    a2 * outputSignal(n - 2, i);
            <span class="keyword">case</span> <span class="string">'6'</span>
                outputSignal(n, i) = <span class="keyword">...</span>
                    b0 * inputSignal(n, i) + <span class="keyword">...</span>
                    b1 * inputSignal(n - 1, i) - <span class="keyword">...</span>
                    a1 * outputSignal(n - 1, i) + <span class="keyword">...</span>
                    b2 * inputSignal(n - 2, i) - <span class="keyword">...</span>
                    fnl(a2 * outputSignal(n - 2, i));
            <span class="keyword">case</span> <span class="string">'7'</span>
                outputSignal(n, i) = <span class="keyword">...</span>
                    b0 * inputSignal(n, i) + <span class="keyword">...</span>
                    b1 * inputSignal(n - 1, i) - <span class="keyword">...</span>
                    fnl(a1 * outputSignal(n - 1, i)) + <span class="keyword">...</span>
                    b2 * inputSignal(n - 2, i) - <span class="keyword">...</span>
                    fnl(a2 * outputSignal(n - 2, i));
            <span class="keyword">case</span> <span class="string">'8'</span>
                outputSignal(n, i) = <span class="keyword">...</span>
                    fnl(b0 * inputSignal(n, i) + <span class="keyword">...</span>
                    b1 * inputSignal(n - 1, i) - <span class="keyword">...</span>
                    a1 * outputSignal(n - 1, i) + <span class="keyword">...</span>
                    b2 * inputSignal(n - 2, i) - <span class="keyword">...</span>
                    a2 * outputSignal(n - 2, i));
            <span class="keyword">case</span> <span class="string">'9'</span>
                outputSignal(n, i) = <span class="keyword">...</span>
                    fnl(b0 * inputSignal(n, i)) + <span class="keyword">...</span>
                    b1 * inputSignal(n - 1, i) - <span class="keyword">...</span>
                    fnl(a1 * outputSignal(n - 1, i)) + <span class="keyword">...</span>
                    b2 * inputSignal(n - 2, i) - <span class="keyword">...</span>
                    fnl(a2 * outputSignal(n - 2, i));
            <span class="keyword">otherwise</span>
                error(<span class="string">'Invalid topology.'</span>);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">if</span> any(isinf(outputSignal), <span class="string">'all'</span>)
    error(<span class="string">'outputSignal contains Inf value.'</span>)
<span class="keyword">end</span>
</pre>
<h2 id="8">Normalization</h2>
<p>Avoid clipping.</p>
<pre class="codeinput">maxValues = max(outputSignal);
minValues = min(outputSignal);
absoluteMaxValue = max(max(abs(maxValues)), max(abs(minValues)));
normalizedOutputSignal = outputSignal ./ absoluteMaxValue;
</pre>
<h2 id="9">Results</h2>
<pre class="codeinput">
<span class="comment">% soundsc(normalizedOutputSignal, fs);</span>
<span class="comment">%</span>
<span class="comment">% [filepath, name, ext] = fileparts(filename);</span>
<span class="comment">% newFilename = sprintf('%s/%s_%s_%s%s', filepath, name, topology, nonlinearity, ext);</span>
<span class="comment">% audiowrite(newFilename, normalizedOutputSignal, fs);</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% ELEC-E5620 Audio Signal Processing 2023, Demo project: Moog Ladder Filter
% Pi, Wang, Benc
%
% Implements and demonstrates nonlinearity by saturating different members
% of the difference equation of the second-order biquad filter.
% 
% References:
% [1] Configure the Coefficients for Digital Biquad Filters in
% TLV320AIC3xxx Family [online], 2010. Available: http://www. ti.
% com/lit/an/slaa447/slaa447. pdf. 
% [2] Chowdhury, "STABLE STRUCTURES FOR NONLINEAR BIQUAD FILTERS,” 
% Proceedings of the 23rd International Conference on Digital Audio Effects
% (DAFx-20), Vienna, Austria, September 8–12, 202.
%
% Parameters:
% fc    - Cut-off frequency (Hz).
% Q     - Quality value (dB).
% fs    - Sampling frequency (Hz).
% topology  - Filter topology. Options: 
%               '0', ..., '9' - According to the chart attatched to the code.
% nonlinearity  - Nonlinearity type. Options:
%                   'soft' - Soft saturator. 
%                   'hard' - Hard saturator.
%                   'tanh' - Tanh saturator.
% fs    - Sampling frequency (Hz).
% inputSignal   - Wave signal.
%
% Output:
% normalizedOutputSignal  - Nomalized filtered signal.

%%

clear; clc; close all;

%% Parameters

fc=1000;
Q=10;
topology = '1';
nonlinearity = 'hard';

%% Input signal

% % Generate a logarithmic chirp signal
% fs = 48e3;
% t = 0:1/fs:10;
% f0 = 20;
% f1 = 20000;
% y = chirp(t, f0, max(t), f1, 'logarithmic');
% audiowrite('samples/sweep.wav', y, fs);

filename = 'samples/sweep.wav';
[inputSignal, fs] = audioread(filename);


%% Calculation of the biquad filter coefficients [1]

w=2*pi*fc/fs;
alpha=sin(w)/(2*Q);
b0=(1-cos(w))/2;
b1=(1-cos(w));
b2=(1-cos(w))/2;
a1=-2*cos(w);
a2=1-alpha;

%% Stability test
% Assuming that the corresponding linear filter is stable, the nonlinear
% feedback filter will be stable provided the absolute value of the
% derivative of fnn is always less than or equal to 1. [2]

b = [b0, b1, b2];
a = [1, a1, a2];
flag = isstable(b, a); 

figure;
zplane(b, a);
title('Pole-zero plot');

if flag==1
    disp('Corresponding linear filter is stable.');
else
    disp('Corresponding linear filter is unstable.');
end

%% Nonlinearity function
% Defining nonlinearity function used for saturation.

if nonlinearity=='soft'
    fnl = @(x) 3.*(1 ./ (1 + exp(-x))-0.5);
elseif nonlinearity=='hard'
    fnl = @(x) (x < -1) .* -1 + (x >= -1 & x <= 1) .* x + (x > 1) .* 1;
elseif nonlinearity=='tanh'
    fnl = @(x) tanh(x);
else
    error('Invalid nonlinearity type.')
end

%% Filtering
% Applying the filtering based on the topology.

outputSignal = zeros(size(inputSignal));

for i=1:size(inputSignal, 2)
    for n = 3:length(inputSignal)
        switch topology
            case '0'
                outputSignal(n, i) = ...
                    b0 * inputSignal(n, i) + ...
                    b1 * inputSignal(n - 1, i) - ...
                    a1 * outputSignal(n - 1, i) + ...
                    b2 * inputSignal(n - 2, i) - ...
                    a2 * outputSignal(n - 2, i);
            case '1'
                outputSignal(n, i) = ...
                    b0 * inputSignal(n, i) + ...
                    b1 * inputSignal(n - 1, i) - ...
                    a1 * outputSignal(n - 1, i) + ...
                    b2 * inputSignal(n - 2, i) - ...
                    a2 * outputSignal(n - 2, i);
            case '2'
                outputSignal(n, i) = ...
                    b0 * inputSignal(n, i) + ...
                    b1 * inputSignal(n - 1, i) - ...
                    a1 * outputSignal(n - 1, i) + ...
                    fnl(b2 * inputSignal(n - 2, i) - ...
                    a2 * outputSignal(n - 2, i));
            case '3'
                outputSignal(n, i) = ...
                    b0 * inputSignal(n, i) + ...
                    fnl(b1 * inputSignal(n - 1, i) - ...
                    a1 * outputSignal(n - 1, i)) + ...
                    fnl(b2 * inputSignal(n - 2, i) - ...
                    a2 * outputSignal(n - 2, i));
            case '4'
                outputSignal(n, i) = ...
                    fnl(b0 * inputSignal(n, i) + ...
                    b1 * inputSignal(n - 1, i)) - ...
                    a1 * outputSignal(n - 1, i) + ...
                    fnl(b2 * inputSignal(n - 2, i)) - ...
                    a2 * outputSignal(n - 2, i);
            case '5'
                outputSignal(n, i) = ...
                    b0 * inputSignal(n, i) + ...
                    b1 * inputSignal(n - 1, i) - ...
                    fnl(a1 * outputSignal(n - 1, i)) + ...
                    b2 * inputSignal(n - 2, i) - ...
                    a2 * outputSignal(n - 2, i);
            case '6'
                outputSignal(n, i) = ...
                    b0 * inputSignal(n, i) + ...
                    b1 * inputSignal(n - 1, i) - ...
                    a1 * outputSignal(n - 1, i) + ...
                    b2 * inputSignal(n - 2, i) - ...
                    fnl(a2 * outputSignal(n - 2, i));
            case '7'
                outputSignal(n, i) = ...
                    b0 * inputSignal(n, i) + ...
                    b1 * inputSignal(n - 1, i) - ...
                    fnl(a1 * outputSignal(n - 1, i)) + ...
                    b2 * inputSignal(n - 2, i) - ...
                    fnl(a2 * outputSignal(n - 2, i));     
            case '8'
                outputSignal(n, i) = ...
                    fnl(b0 * inputSignal(n, i) + ...
                    b1 * inputSignal(n - 1, i) - ...
                    a1 * outputSignal(n - 1, i) + ...
                    b2 * inputSignal(n - 2, i) - ...
                    a2 * outputSignal(n - 2, i));                 
            case '9'
                outputSignal(n, i) = ...
                    fnl(b0 * inputSignal(n, i)) + ...
                    b1 * inputSignal(n - 1, i) - ...
                    fnl(a1 * outputSignal(n - 1, i)) + ...
                    b2 * inputSignal(n - 2, i) - ...
                    fnl(a2 * outputSignal(n - 2, i));
            otherwise
                error('Invalid topology.');
        end
    end
end

if any(isinf(outputSignal), 'all')
    error('outputSignal contains Inf value.')
end

%% Normalization
% Avoid clipping.

maxValues = max(outputSignal);
minValues = min(outputSignal);
absoluteMaxValue = max(max(abs(maxValues)), max(abs(minValues)));
normalizedOutputSignal = outputSignal ./ absoluteMaxValue;

%% Results

% soundsc(normalizedOutputSignal, fs);
% 
% [filepath, name, ext] = fileparts(filename);
% newFilename = sprintf('%s/%s_%s_%s%s', filepath, name, topology, nonlinearity, ext);
% audiowrite(newFilename, normalizedOutputSignal, fs);


##### SOURCE END #####
-->
</body>
</html>
